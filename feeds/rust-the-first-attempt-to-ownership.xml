<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Yuuno Blog | Rust: The first attempt to ownership</title>
<icon>https://yuuno.cc//favicon.jpg</icon>
<link href="https://yuuno.cc/feeds/rust-the-first-attempt-to-ownership.rss" rel="self"/>
<link href="https://yuuno.cc/articles/rust-the-first-attempt-to-ownership"/>
<updated>2019-12-18T04:31:28.959Z</updated>
<id>rust-the-first-attempt-to-ownership</id>
<author>
<name>Yuuno Hibiki</name>
</author>
<generator uri="https://github.com/NHibiki/ReSlice">ReSlice</generator>
<entry>
<title>Rust: The first attempt to ownership</title>
<link href="https://yuuno.cc/articles/rust-the-first-attempt-to-ownership"/>
<id>rust-the-first-attempt-to-ownership</id>
<published>2019-12-18T04:31:28.959Z</published>
<updated>2019-12-18T04:31:28.959Z</updated>
<content type="html"><![CDATA[<blockquote><p>上一篇 <a href="https://yuuno.cc/articles/rust-brief-intro-to-safe">Rust: Brief Intro to SAFE</a></p></blockquote><h3>前言</h3><p>这篇文章是继第一篇初探 Rust 之后的续集。在之前那篇博客中，我简介了我对 Rust 的看法，并且定下了我的学习里程碑计划。今天，我会在这篇文章讲述对 Rust 的 LinkedList 系列的实现，以及简介它的部分 Syntax。</p><p>首先，为什么要学习用 Rust 实现 LinkedList？</p><p>我个人的理解是，Rust 之所以与其他编程语言不同，关键在于它的 <em>“所有权“</em> 和 <em>“生命周期“</em>。换言之，在编写 Rust 的过程中，对于自己创建的每一个变量，包括临时变量，都要对它的作用范围了如指掌。因此，我们可以找一个相对复杂的案例（譬如 LinkedList）来加深自己对这两个关键词的理解。但或许你会说，LinkedList 又不是复杂环境！不如直接上手 Map（key 与 value 甚至都可以是不同生命周期的案例）。当然！你当然可以！不过 LinkedList 对于初学者而言，是一个 “我们都清楚它的原理，但不清楚它的生命周期“ 的最简单案例。中间并没有复杂的逻辑，我们只需要一心扑在我们想学的知识点即可。这样的做法，更直接，也更容易有收获。（毕竟这个 LinkedList 花了我整整半天的时间去 debug）</p><h3>初版</h3><blockquote><p>实现 LinkedList Implement 的Stack</p></blockquote><p>这是一个反例，我后悔自己没有仔细规划就开始动手码代码。以至于即便是一个 Stack 最后都变成了 DOP (<em>debug oriented programming</em>)。</p><p>首先我构建了两个简单的 struct：</p><pre><code class="language-rust"> pub struct Node&#x3C;T> {    pub next: Option&#x3C;Box&#x3C;Self>>,    pub value: T,}pub struct Stack&#x3C;T> {    pub head: Node&#x3C;T>,    pub length: usize,}</code></pre><p>这个结构再简单不过，Node能<strong>拥有</strong>自己的值，也拥有一个<em>可空</em>的指针指向下一个节点。</p><p>然后，我们只需要把它的下一个节点新建并放入之间的那个节点中，就能把这些节点连起来了：</p><pre><code class="language-rust">impl&#x3C;T> Stack&#x3C;T> {    fn push(&#x26;mut self, v: T) -> &#x26;mut Self {        self.length += 1;        let mut node = Node::new(v);        node.next = self.head.next;        self.head.next = Some(Box::new(node));        self    }}</code></pre><p>很简洁，很直观，甚至支持链式调用，但是也报了很多错。</p><p>编译器这时候不乐意了：虽然你说的都对，但是我没办法帮你复制<code>*self</code>。</p><pre><code class="language-rust">node.next = self.head.next;|move occurs because `self.head.next` has type `std::option::Option&#x3C;std::boxed::Box&#x3C;Node&#x3C;T>>>`, which does not implement the `Copy` trait</code></pre><p>原因是，<code>=</code> 在 Rust 中有两层语义，一个是赋值，一个是所有权转移或者借用，由于 <code>Option&#x3C;Box&#x3C;Node&#x3C;T>>></code> 并不是基类，从它赋值的时候，Rust 需要知道如何<em>拷贝</em>。（譬如我们知道，在 python 和 javascript 中，这个等号代表了新建了一个 reference），而 Rust 并不知道你的 struct 中哪些需要被转移所有权，哪些需要借用，又或者哪些需要直接拷贝（u8, i32这些）。</p><p>编译器原本希望我能把它 Copy 出去，但是并不是所有类都能实现 Copy trait（譬如 String），所以，这里最直接的解决方法告诉编译器，我不需要复制任何变量，你把它所有权收走就行 <code>node.next = self.head.next.take();</code>，于是，在此之后，这个 <code>next</code> 的所有者就从 <code>self.head</code> 转移到了 <code>node</code> 上。</p><p>最后，将它封装起来的成品：</p><pre><code class="language-rust">pub struct Node&#x3C;T> {    pub next: Option&#x3C;Box&#x3C;Self>>,    pub value: Option&#x3C;T>,}impl&#x3C;T> Node&#x3C;T> {    fn new(v: T) -> Self {        Node {            next: None,            value: Some(v),        }    }    fn new_empty() -> Self {        Node {            next: None,            value: None,        }    }}pub struct Stack&#x3C;T> {    pub head: Node&#x3C;T>,    pub length: usize,}impl&#x3C;T> Stack&#x3C;T> {    fn new() -> Self {        Stack {            head: Node::new_empty(),            length: 0,        }    }    fn push(&#x26;mut self, v: T) -> &#x26;mut Self {        self.length += 1;        let mut node = Node::new(v);        node.next = self.head.next.take();        self.head.next = Some(Box::new(node));        self    }    fn pop(&#x26;mut self) -> Option&#x3C;T> {        self.length -= 1;        let node = self.head.next.take();        if let Some(pk) = node {            self.head.next = pk.next;            pk.value        } else {            None        }    }    fn index(&#x26;mut self, idx: usize) -> Option&#x3C;&#x26;T> {        let mut k = &#x26;self.head;        let mut i = idx;        while let Some(pk) = &#x26;k.next {            k = &#x26;pk;            if i == 0 {                if let Some(v) = &#x26;k.value {                    return Some(&#x26;v);                } else {                    return None;                }            };            i -= 1;        }        None    }    fn for_each&#x3C;U>(&#x26;mut self, p: U) where U: Fn(&#x26;T) {        let mut k = &#x26;self.head;        while let Some(pk) = &#x26;k.next {            k = &#x26;pk;            if let Some(v) = &#x26;k.value {                p(&#x26;v);            } else {                return;            }        }    }    fn reverse(&#x26;mut self) -> Self {        let mut new = Self::new();        while self.length > 0 {            new.push(self.pop().unwrap());        }        new    }}</code></pre><p>以及用于测试的案例：</p><pre><code class="language-rust">fn main() {    let mut a: Stack&#x3C;&#x26;str> = Stack::new();    a.push("Hi,")     .push("this")     .push("is")     .push("fancy");    let b = a.pop();    a.push("a")     .push("trial!");    a.for_each(|v| {        print!("{} ", v);    });    println!("\nGot b={} from a[{}]", b.unwrap(), &#x26;a.length);    println!("Got a[3]={}", a.index(3).unwrap_or(&#x26;"undefined"));    println!("Got a[5]={}", a.index(5).unwrap_or(&#x26;"undefined"));    let mut a = a.reverse();    println!("\nReversed:");    a.for_each(|v| {        print!("{} ", v);    });}</code></pre><p>输出结果：</p><pre><code class="language-bash">[Running] cd "/User/nyu/dev/linked-test/src/" &#x26;&#x26; rustc linked.rs &#x26;&#x26; "/User/nyu/dev/linked-test/src/"linkedtrial! a is this Hi, Got b=fancy from a[5]Got a[3]=thisGot a[5]=undefinedReversed:Hi, this is a trial! [Done] exited with code=0 in 0.472 seconds</code></pre><h3>问题</h3><p>如果你在读代码的时候感觉这个代码有问题，那恭喜你！虽然它运行起来没问题，但其实它有很大的又不重要的问题 - -：</p><ul><li><strong>对值的绝对控制</strong>：这个案例中，Stack 默认索取了被 push 的内容的所有权和生命周期。当然，我们确实可以新建一个引用来解决问题（如上面的案例 <code>Stack&#x3C;&#x26;str></code>），但总是感觉没那么美观。（并且，如果我们希望用 Box 来承接引用，我们就需要手动规定被承接内容的生命周期（<code>pub next: Option&#x3C;Box&#x3C;&#x26;'a Self>></code>）。）</li><li><strong>很难实现的 Iterator</strong>：Rust 官方支持 <code>Iterator</code> trait 和 <code>IntoIterator</code> trait，前者可以使 struct 具有被 <code>for</code> 遍历的功能，并且支持 <code>.iter()</code> 和 <code>.iter_mut()</code>，后者允许从一个类中拓展出一个支持遍历的子类<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">（参考资料）</a>。不过，在这个案例中，由于 <code>next</code> 都是实实在在存在实体而不是一个 reference，导致构架 Iterator 难度急剧上升（当然可能是我没想到好的方法）。在我自己的实验中，可以拓展 <code>stack.for_each</code>，并使用试验性的 Generator 来达成目的，不过毕竟 Generator 还是实验性的，实战中并无法使用。</li></ul><h3>总结</h3><p>真正的编码过程其实并没有上面展示的这么容易，中间绕了很多弯路，不过大部分的错误都是类似的：</p><pre><code class="language-rust">|move occurs because *** has type ***, which does not implement the `Copy` trait</code></pre><p>以及，生命不够长的问题（这么说好像也没什么不对 - -）。</p><p>不过，综合来说，还是对自己设定的变量的掌控力不足。</p><p>这款语言或许不可能成为世界上最流行的语言，但它对于计算机安全以及可持续化的冲击力是不可估量的。</p>]]></content>
<summary type="html">
上一篇,Rust:BriefIntrotoSAFE,前言,这篇文章是继第一篇初探Rust之后的续集。
</summary>
<category term="Notes" scheme="https://yuuno.cc/categories/Notes"/>
<category term="Rust" scheme="https://yuuno.cc/tags/Rust"/>
<category term="Notes" scheme="https://yuuno.cc/tags/Notes"/>
</entry>
</feed>