---
title: 'Deno: The First Trial'
date: 2020-05-20T18:45:54.484Z
categories:
  - Tech
tags:
  - Deno
  - JavaScript
  - Server
---

> 已经半年没有更新博客了。（给自己找一些不成文的借口）一方面在这个新冠的特殊时期还要双专业毕业，实属有些忙不过来；另一方面，这学期学的内容，以及给自己安排的项目过于杂乱，导致很长时间没能静下心来提炼一下。

### 前语

首先，这篇文章是建立在我短暂接触 *Deno* 正好正式版一周时写的文章。这时候的我还没有开始阅读 *Deno* 的源码，对于它的见解只是个人的和片面的。或许当我了解 *Deno* 的结构之后会对它进行重新的评价。

### 介绍

什么是 *Deno*？作者讲的很明白，可以直接去官网了解：https://deno.land。*Deno* 的官网（包括网址）即给人一种脱俗的感觉，同时也能看出 Ryan Dahl （设计者）的用心。

为什么不是 *Node 20.0.0* 而是 *Deno 1.0.0*？我相信大多数尝鲜者的博客都有类似的回答了：因为 *Node* 一发不可收拾的历史原因：越来越多的 *TypeScript* 信徒，以及令人无法着眼的 *node_modules* 设计。仅仅如此吗？当然不是。从 *Deno 1.0* 的特性来看。Ryan Dahl 的野心不止于此。我能想到的有如下：

- 在脚本语言中，它的同胞们 *python*，*ruby* 都进入或者半进入了 *\*nix* 的 distro，然而，*Node* 因为脚本依赖太过复杂的问题迟迟未能胜任系统脚本的重担。
- *Node* 作为一个服务器软件，它的权限控制是不够的（当然，这虽然被作者提及，但其实是一个非常普遍的问题。我甚至认为这点比较个人色彩）
- *Node* 的包引用，乃至是 *API* 管理太过混乱。虽然大家都或多或少遵从 *ECMAScript*，且不说 Async 与 Event 的实现方式不同，它们的表层 *API* 都有巨大的区别：*window对象*，*CJS/ESM* 等等。

这和 Ryan Dahl 的初衷有别，或者说，原本的 *Node* 在让事情变得更加复杂，于是，就有了 *Deno* 的诞生。

### 设计方式

由于还没有深入到源码中，这里只能粗谈一下。若有遗漏或者错误的地方，之后会进行补充。

*Deno* 给人最大的感觉就是：新。

它引入的几乎都是最新的：*Golang*，*Rust*，*TypeScript*，运行时权限控制和沙箱，单文件，*FaaS*。

*Golang* 和 *FaaS* 可能让人有些疑惑，我会稍微解释下：*Deno* 最开始是使用 *Golang* 进行设计的（在 GitHub Repo 中都能看到被遗弃的分支），因此，*Deno* 的一些概念/API也或多或少借鉴了 *Golang*，比如 *Conn*，*Dial* 的结构和 *API*。至于 *FaaS*，我之所以有这种感觉是因为 *Deno* 把文件看作是一个整体 -- 它可以被认为是唯一的入口，不需要携带额外的配置，具有独立的权限控制和运行环境。这给人的感觉是一个 *SingleFile-As-A-Service*。虽然我不知道作者是否有意如此设计，不过对于我这个容器的高度使用者来说，这样独立的设计是让我非常中意的。

另外让人眼前一亮的是，终于有人开始统一 *Node*(*Deno*) 与 *Browser* 的规范了。（这固然是好事，但也是很大的挑战。毕竟他们的场景天差地别。）

*Deno* 支持，并且只会支持 *ESM* 的引入方法，可以直接从 **URI** 导入外部库（这与开启了 `type=module` 的浏览器端 *ESM* 部分接轨）。这里之所以说是 **URI**，是因为你不仅仅可以从文件系统读取模组，你也可以从网上加载内容。

### 缺陷

*Deno* 作为一个新生儿，缺陷看看 *GitHub* 的 *Issue* 数目就知道了。虽然它成功迈入了正式版，不过我个人建议还是暂时官网，除非：1. 这是一个团队作业，有大佬撑着；2. 无所谓生态的问题。（虽然 *Deno* 声称可以完美兼容所有现有编译完全的 *ts*/*js* 库，但是，它毕竟还是与 *Node* 底层 API 就不同，能不能正常使用，就是未知的了，例如，依赖于 `fs`，`crypto`的库）

这里，我仅仅谈谈我的使用上感觉的不足（中间有一些以及纳入 milestone，会在不久的未来不构成问题）：

1. **URI规范模糊**：虽然官方支持从 *URI* 导入库，但是 1) *URI* 是支持资源注册的，比如 `s3://`，不能只是单方面支援 `https://`。2) *URI* 引库也需要 `--allow-read`，与 `--allow-net`授权，这（个人认为）是不合理的。权限应该约束在库中的读取行为，而并不是读取库这个行为。
2. **TS支持欠佳**：虽然 *TypeScript* 的支持是令人振奋的，单文件的设计又免除了大量的 *tsconfig* 和 *webpack*。但是，这意味这 *TypeScript* 的大部分糖，或者说实验性功能都无法被使用，比如 *decorator*。于是，除非 *Deno* 最终可以左右 *TypeScript* 的生态，不然它永远不可能成为第一 *TypeScript* 开发工具，而只是一个运行工具（有的甚至无法运行）。
3. **无法统一管理的依赖**：这是缺点，但也不是。没有统一的依赖管理器意味着你不同文件中引用的可能是不同版本的库（看，又是`node_modules`的影响），以至于如果需要做大规模的项目，开发者会被强制自我封装一个本地类来确保版本一致性（`import` 再统一 `export`）（对不起我无法 cite，在过去两天中我看到 *StackOverflow* 中有朋友提到过以此作为解决方案，不过我未能在写作时找到）。

### 总结

以上就是我于正式版发布一周后写下的使用感受，对于我个人而言，我很喜欢 *Deno* 的设计和理念，以至于我迫不及待地准备阅读它的源码。但它依旧没能从根本上解决一些问题（或者说只是表面藏匿了曾经的问题）。我相信随着时间的推移，它会是一个不错的服务端 *Js/Ts* 解释器，但是确实还需要时间。让我们拭目以待。
