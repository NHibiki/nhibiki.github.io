---
title: "AudioStream: 使用 Go 和 icecast 制作自己的 web 广播流"
tags:
  - Music
  - Golang
categories:
  - Tech
date: 2018-12-19 11:45:51
---

### 前言

好久没有更新技术博文了，一方面是因为随着接的活越来越多，写的代码越来越多，研究新事物的时间也就越来越少。另一方面，由于我的技术栈逐渐趋于稳定，我可能需要把更多的时间花在研究，或者最新的科技上，而不能整体把弄一些“我已经熟知的领域”了。（虽然我明白对很多人而言，*stick to one* 是更好的选择，不过嘛，我就是一个不折腾不开心的人 QwQ）

于是，在工作/学习闲暇的时间，（其实是期末考试的空隙）写了这篇小短文，讲讲我最近*无聊*的玩意儿 -- *sCast* 一个使用 QQ音乐 为音乐源的 网络音乐流 实现方法。

### 简介

首先，什么是*网络音乐流*？我给的定义是，一种在线实时音乐 *stream*。这样，我只需要一个 *url* 就可以在任何地方播放一个 *歌单*。而不需要下载这个播放器，下载哪个播放器，而且，随时同步。

其实，一年前，我已经有过类似的研究：[【AudioStream: 用 Python 建立自己的音乐流】](https://yuuno.cc/articles/combine-ice-with-python)。在那篇文章中，我使用了 *python*，*libshout*，和 *icecase* 来完成一个静态文件目录的音乐流。

这是一个很好的开始，但是终究不是最好的解决方法。因为，维护一个静态文件目录就代表，维护成本非常大 -- 500首音乐就需要占用 *6GB* 空间（如果按照*320kbps*的*mpeg*文件来算）。迁移，筛选，都是一个巨大的问题。

所以就有的 *sCast* 的诞生。

### 分析

首先选择技术栈，我一开始的偏好为：*Docker* - *Alpine3.8* - \[*Go(musl)* + *libshout* + *ffmpeg* + *icecast*\]。

这看似是一个非常清晰的结构，但是制作音乐流服务器的过程，其实挺令人不快的。因为，实现逻辑虽然清晰，但却遇到了很多“伪版权”问题（即不合理的版权逻辑问题）。所以在写代码的时候重做了很多次，并且变得很复杂 ...

首先，一开始我选择的并不是QQ音乐，而是网易云音乐。但是在搜遍所有的网页，*Github* 的每一个角落，发现现有的 *API* 都失效了。我都打算放弃了，却注意到，有一个用 *nodejs* 写的 *API* 服务还在维护中<sup>[1](#appendix)</sup>，而且，并没有人提 *issue*。于是我意识到，应该不是 *API* 失效，而是我的姿势不对。于是我把 *nodejs* 项目中的代码翻译成了 *Go*。然而，等待我的，又是一个失败。

我觉得很奇怪，没道理 *Go* 的 *request* 和 *node* 的 *request* 不一样啊！难道是我下了华强北的 *Go*？（开玩笑的）于是，我干脆把这个 *nodejs* 的版本 *clone* 下来跑了下，确实也不成功（呼，至少我的 Go 没问题 :)。那天晚上在睡觉的时候我猛然想到会不会是网易 *API* 用了 *geoip*，把我屏蔽了（。这个点子让我兴奋了一晚上，第二天连懒觉都没睡就又试了下。果然！开了台阿里云国内代理，一下子就拿到了 *url*。

其实我应该早点想到。毕竟写 *API* 的这些人都在局域网内，咱的情况，好像还没有人遇到过 2333。

成功虽然是成功了，但却有违我的初衷 -- 那这样我岂不是要维护国内阿里云服务器？开什么玩笑，*5M* 的带宽只跑一个这么小的服务，还要备案？于是，我尝试这能否只用代理请求 *API*，而不架代理下载歌曲。结果很现实：失败。

咸鱼了两天后，我还不死心，又想试试 QQ：您网易不行，不代表其他音乐服务商就不行啊！这次我学乖了，先不写代码，看看 api 能否走通。发现，QQ就很笨，只有 *API* 做了 *geoip* 过滤，音乐存储服务器并没有。这就意味着，我可以随便开一家国内的虚拟主机，扔个 *API* 上去，反正流量不大。在国外的 *stream* 服务器通过国内的 *API* 服务器拿到数据，再进行缓存，（转换格式，）切 *chunk*，推流。这样甚至逃过了每次听过都要走代理的限制，非常省力。

### 开发

*API* 的开发过程我就不讲了，毕竟不过就是几个 *requests* + *redis* 缓存。Go 在这些方面非常优秀，又快又省内存，一个 *docker image* *6MB* 不到（比 *python* 安装文件都小好几倍 :) 开玩笑的，业务不同，应用场景不同，无可对比性）

具体讲的是推流。

首先，我们需要用到一个库：*libshout*，这是 *icecast* 实现的一个 *C Library*，用于实现给 *icecast* 推流。既然我们用的是 *Go*，那就自然会提到 *Go* 与 *C* 联调的优越性：bind 一下，就完全解决了。（当然这里我们用到了一个 5年前 的历史库 *go-libshout*<sup>[2](#appendix)</sup>）基本的用法非常清晰（这里建议直接看源码，个人觉得他的示例代码还不如源码容易理解 2333）

然后，我们只需要用 `http.Get` 方法，把 `resp.Body` 推入初始化好的 `chan []byte` 就好了。

不过，因为考虑到使用的 QQ音乐 *API* 不是所有歌都有 *mp3* （访问 *M800....mp3* 有的歌曲会 *404*），稳妥的方案是获取 *m4a* 格式，然后再转换为 *mp3* 推流。

所以，我们更改之前直接推 *binary* 的方法，我们用 `io.Copy` 把文件缓存下来，再调用 *ffmpeg* 进行转码。（这里其实也有人说可以直接用 *ffmpeg* 推，但是鉴于之后我还想写一个 *ws* 的信息流，所以就不采用此方法，尽可能用 Go 实现推流）

这时候，遇到了一个问题 - -。好好的 *mp3* 在推流的时候居然报错了：

```sh
something went wrong: -4
```

查看源码后，发现是 *stream disconnected error*，百思不得其解。搜了大量的 *Google* 后才了解到，*icecast* 会自动关闭一段时间没有推任何东西的链接，至于这个*一段时间*是多久，官方也没有说 2333。但是他们推荐即便播放任何东西，也要推空音频数据来维持链接。

我当然懒得找空音频，于是，只能调整代码策略。在全局加个 *flag*，当 *go routine* 成功转码第一个文件之后再启动 *stream*。

至此，完美结束。

以上

### 附录 {#appendix}

1. https://github.com/Binaryify/NeteaseCloudMusicApi
2. https://github.com/systemfreund/go-libshout
